#include "cache.h"

#define IT_SIZE 256
#define IT_INDEX_MASK (IT_SIZE - 1)
#define GHB_SIZE 256
#define NUM_LAST_ENTRIES 3

typedef struct IT_Entry IT_Entry;
typedef struct GHB_Entry GHB_Entry;

// entry of the index table
struct IT_Entry {
    uint64_t ip;
    GHB_Entry *ghb_ptr;
};

// entry of the global history buffer
struct GHB_Entry {
    uint64_t addr;
    GHB_Entry *prev;
    GHB_Entry *next;
    IT_Entry *it;
};

uint64_t prefetch_distance = 4;
uint64_t prefetch_degree = 4;

// index table
IT_Entry it[IT_SIZE];

// global history buffer
GHB_Entry ghb[GHB_SIZE];
int ghb_head_idx;


void CACHE::l2c_prefetcher_initialize() 
{
    cout << "CPU " << cpu << " L2C GHB prefetcher" << endl;
}

uint32_t CACHE::l2c_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint32_t metadata_in)
{
    std::vector<uint64_t> pf_addr_list;
    if (type != LOAD) {
        return metadata_in;
    }

    uint64_t it_idx = IT_INDEX_MASK & ip;
    uint64_t cl_addr = addr >> LOG2_BLOCK_SIZE;

    // get entry from index table for given instruction pointer
    IT_Entry *it_entry = it + it_idx;

    // a collision -> replace the old index table entry
    if (it_entry->ip != ip) {
        it_entry->ip = ip;
        it_entry->ghb_ptr = NULL;
    }

    GHB_Entry *ghb_entry = ghb + ghb_head_idx;

    // >>>>>>>>>> Collision Catch in GHB Starts >>>>>>>>>>
    // invalidate prev of more recent GHB entry
    if (ghb_entry->next) {
        ghb_entry->next->prev = NULL;
    }

    // invalidate IT entry
    if (ghb_entry->it) {
        ghb_entry->it->ghb_ptr = NULL;
    }
    // <<<<<<<<<<< Collision Catch in GHB Ends <<<<<<<<<<<

    // insert new entry into GHB 
    ghb_entry->addr = cl_addr;
    ghb_entry->prev = it_entry->ghb_ptr;
    ghb_entry->it = it_entry;
    it_entry->ghb_ptr = ghb_entry;

    // increment GHB head
    ghb_head_idx = (ghb_head_idx + 1) % GHB_SIZE;

    // update pointers of previous entry
    if (ghb_entry->prev) {
        ghb_entry->prev->next = ghb_entry;
        ghb_entry->prev->it = NULL; // no longer the latest ghb entry, so dont track the IT entry anymore
    }

    // calculate prefetch addresses
    pf_addr_list.clear();
    GHB_Entry last_entries[NUM_LAST_ENTRIES];
    GHB_Entry *curr = ghb_entry;

    int num_entries = 0;
    for (; curr != NULL && num_entries < NUM_LAST_ENTRIES; num_entries++) {
        last_entries[num_entries] = *curr;
        curr = curr->prev;
    }

    // Only start prefetching when we have 3 latest track records
    if (num_entries == NUM_LAST_ENTRIES) {
        int64_t stride[NUM_LAST_ENTRIES - 1];

        // calculate strides between last entries
        for (int i=0; i < NUM_LAST_ENTRIES-1; i++) {
            if (last_entries[i].addr > last_entries[i+1].addr) {
                stride[i] = last_entries[i].addr - last_entries[i+1].addr;
            } else {
                stride[i] = last_entries[i+1].addr - last_entries[i].addr;
                stride[i] *= -1;
            }
        }
        
        // detect stride
        bool stride_detected = false;
        for (int i = 0; i < NUM_LAST_ENTRIES-1; i++) {
            if (stride[i] == 0) {
                // abort if we see the same address twice
                return metadata_in;
            }

            for (int j=i+1; j<NUM_LAST_ENTRIES-1; j++) {
                stride_detected = (stride[i] == stride[j]);
            }
        }

        if (stride_detected) {
            // prefetch addresses based on prefetch degree and distance
            for (uint64_t i = 0; i < prefetch_degree; i++) {
                uint64_t pf_addr =
                            (cl_addr + (stride[0] * (prefetch_distance + i))) << LOG2_BLOCK_SIZE;
                if ((pf_addr >> LOG2_PAGE_SIZE) != (addr >> LOG2_PAGE_SIZE))
                    break;
                pf_addr_list.push_back(pf_addr);
            }
        }
    }

    for (uint64_t pf_addr : pf_addr_list) {
        prefetch_line(ip, addr, pf_addr, FILL_L2, 0);
    }

    return metadata_in;
}

uint32_t CACHE::l2c_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in)
{
  return metadata_in;
}

void CACHE::l2c_prefetcher_final_stats()
{
    cout << "CPU " << cpu << " L2C next line prefetcher final stats" << endl;
}
